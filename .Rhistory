239 / (444 + 239)
#If always 1, all the 0's are errors
444 / (444 + 239)
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 2) #intialize a 2-dim vector
X1 = as.matrix(cbind(1, X[, 1, drop = FALSE]))
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(X1)){
x_i = X1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
yhat = ifelse(X1 %*% w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
y_banary
y_binary
typeof(y_binary)
w_vec
X1
x
1
X1
X
attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1
attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs = as.matrix (scale(attrs)) # normalize the attribute data
attrs1 = as.matrix (scale(attrs1)) # normalize the attribute data
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs)){
x_i = attrs[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix (scale(attrs1)) # normalize the attribute data
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix (scale(attrs1)) # normalize the attribute data
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix (scale(attrs1)) # normalize the attribute data
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
attrs1 = as.matrix (scale(attrs1)) # normalize the attribute data
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
attrs1 = as.matrix (scale(attrs1)) # normalize the attribute data
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
attrr1
attrs1
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
yhat = ifelse(attrs * w_vec > 0, 1, 0)
yhat = ifelse(attrs1 * w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 * w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
iris
#TO-DO
iris = iris[!(iris$Species == 'virginica'),]
#TO-DO
y = as.numeric(iris$Species == "versicolor")
#TO-DO
# We can look at the sepal length distribution of setosa, and versicolor. And see if they are far apart
sepal = iris[ (iris$Species == "setosa"),]$Sepal.Length
mean(sepal)
sd(sepal)
#one way would be to pick as treshold the sepal length under which 95% of the setosas fall
treshold = qnorm(0.95, mean(sepal),sd(sepal))
# what we call                         # what it actually is
num_errors = sum( (iris$Sepal.Length < treshold) != (iris$Species == "setosa")  )
# our error rate
error_rate = num_errors/length(iris$Species)
summary(iris[iris$Species == "setosa", "Sepal.Length"])
summary(iris[iris$Species == "virginica", "Sepal.Length"])
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
yhat = ifelse(attrs1 * w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 * w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
y_binary
iris
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
w_vec
y_binary
as.numeric(iris$Species == "setosa")
''
#TO-DO
library('testthat')
#TO-DO
v <- seq(201)-101
expect_equal(v, -100 : 100)
#TO-DO
my_reverse = function (v) {
v[length(v):1]
}
expect_equal(my_reverse(c("A", "B", "C")), c("C", "B", "A"))
expect_equal(my_reverse(v), rev(v))
n = 50
sample_space = c(0,1,2)
dist = c(0.5, 0.25, 0.25)
random_matrix = rep(sample_space, (n^2)*dist)
shuffled_random_matrix = sample(random_matrix)
shuffled_random_matrix
table(shuffled_random_matrix)
R = matrix(shuffled_random_matrix, nrow = n, ncol = n)
R
#TO-DO
expect_equal(dim(R), c(n, n))
#TO-DO test that the only unique values are 0, 1, 2
unique.values = function(mat) {
as.numeric( dimnames(table(R))[[1]])
}
expect_equal(sort(unique.values(R)), sort(c(2,1,0)))
#TO-DO test that there are exactly 625 2's
expect_equal(table(R)["2"][[1]], 625)
# let p (success) the probability that a location in the matrix will have a hole
holes = rbinom(length(R), size = 1, prob = 0.3)
R[(holes==1)]=NA
#TO-DO
num_missing_in_R = sum(is.na(c(R)))
expect_lt(num_missing_in_R, qbinom(0.995, n^2, 0.3))
expect_gt(num_missing_in_R, qbinom(0.005, n^2, 0.3))
#TO-DO
R_row_sums = rowSums(R,na.rm=TRUE)
ordered_sums = order(R_row_sums)
reversed = my_reverse(ordered_sums)
R = R[reversed,]
for (i in 2 : n){
expect_gte(sum(R[i - 1, ], na.rm = TRUE), sum(R[i, ], na.rm = TRUE))
}
v = rnorm(1000, mean = -10, sd = sqrt(10))
#TO-DO
# STD error function
se = function(x) {
sd(x)/sqrt(length(x))
}
mean(v) #mean
se(v)
#TO-DO
#expect_equal(..., tol = )
sample_quant = qnorm(0.05,mean(v),sd(v)) #  The 5%ile of the sample
percent_below_quant = length ( v[ (v < sample_quant)] ) / length(v) # the calculated % of the observations are below 5% percentile
expect_equal(percent_below_quant, 0.05, tolerance=0.005)
#TO-DO
#expect_equal(..., tol = )
inverse_quantile_obj = ecdf(v)
inv=inverse_quantile_obj(-7000)
#TO-DO
keys = c("A","B","C","D","E","F","G","H")
expect_equal(length(keys), 8) #sanity check
matrixify = function(n) {
x = c(1:n^n)
dim(x) = rep(n,n)
x
}
my_list = lapply(1:8, matrixify)
names(my_list) = keys
expect_equal(my_list$A, 1)
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
#y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
iris
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
#y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
yhat = ifelse(attrs1 * w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 * w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 * w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 %*% w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 %*% w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
%*%
attrs1
w_vec
attrs1 * w_vec
attrs1 * w_vec
attrs1 * w_vec
attrs1 * w_vec
attrs1 * w_vec
attrs1 * w_vec
attrs1 * w_vec > 0
yhat =0
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
print (x_i * w_vec)
}
#sum(y_binary != yhat) / length(y_binary)
attrs1[1,]
attrs1 %*% w_vec
attrs1 %*% w_vec > 0
length(iris)
dim(iris)
iris
iris
yhat = ifelse(attrs1 %*% w_vec > 0, 1, 0)
yhat
yhat = ifelse(attrs1 %*% w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
#TO-DO
library('testthat')
#TO-DO
v <- seq(201)-101
expect_equal(v, -100 : 100)
#TO-DO
my_reverse = function (v) {
v[length(v):1]
}
expect_equal(my_reverse(c("A", "B", "C")), c("C", "B", "A"))
expect_equal(my_reverse(v), rev(v))
n = 50
sample_space = c(0,1,2)
dist = c(0.5, 0.25, 0.25)
random_matrix = rep(sample_space, (n^2)*dist)
shuffled_random_matrix = sample(random_matrix)
shuffled_random_matrix
table(shuffled_random_matrix)
R = matrix(shuffled_random_matrix, nrow = n, ncol = n)
R
#TO-DO
expect_equal(dim(R), c(n, n))
#TO-DO test that the only unique values are 0, 1, 2
unique.values = function(mat) {
as.numeric( dimnames(table(R))[[1]])
}
expect_equal(sort(unique.values(R)), sort(c(2,1,0)))
#TO-DO test that there are exactly 625 2's
expect_equal(table(R)["2"][[1]], 625)
# let p (success) the probability that a location in the matrix will have a hole
holes = rbinom(length(R), size = 1, prob = 0.3)
R[(holes==1)]=NA
#TO-DO
num_missing_in_R = sum(is.na(c(R)))
expect_lt(num_missing_in_R, qbinom(0.995, n^2, 0.3))
expect_gt(num_missing_in_R, qbinom(0.005, n^2, 0.3))
#TO-DO
R_row_sums = rowSums(R,na.rm=TRUE)
ordered_sums = order(R_row_sums)
reversed = my_reverse(ordered_sums)
R = R[reversed,]
for (i in 2 : n){
expect_gte(sum(R[i - 1, ], na.rm = TRUE), sum(R[i, ], na.rm = TRUE))
}
v = rnorm(1000, mean = -10, sd = sqrt(10))
#TO-DO
# STD error function
se = function(x) {
sd(x)/sqrt(length(x))
}
mean(v) #mean
se(v)
#TO-DO
#expect_equal(..., tol = )
sample_quant = qnorm(0.05,mean(v),sd(v)) #  The 5%ile of the sample
percent_below_quant = length ( v[ (v < sample_quant)] ) / length(v) # the calculated % of the observations are below 5% percentile
expect_equal(percent_below_quant, 0.05, tolerance=0.005)
#TO-DO
#expect_equal(..., tol = )
inverse_quantile_obj = ecdf(v)
inv=inverse_quantile_obj(-7000)
#TO-DO
keys = c("A","B","C","D","E","F","G","H")
expect_equal(length(keys), 8) #sanity check
matrixify = function(n) {
x = c(1:n^n)
dim(x) = rep(n,n)
x
}
my_list = lapply(1:8, matrixify)
names(my_list) = keys
expect_equal(my_list$A, 1)
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
y_binary = as.numeric(iris$Species == "setosa")
#y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
yhat = ifelse(attrs1 %*% w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 %*% w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
yhat = ifelse(attrs1 %*% w_vec > 0, 1, 0)
sum(y_binary != yhat) / length(y_binary)
#attrs1 = cbind(1,iris[c(1,2,3,4)])
attrs1 = as.matrix(cbind(1, iris[, c(1,2,3,4), drop = FALSE]))
attrs1 = scale(attrs1)
y_binary = as.numeric(iris$Species == "setosa")
#y_binary = ifelse(y_binary == 1, 0, 1)
MAX_ITER = 1000
w_vec = rep(0, 5) #intialize a 2-dim vector
for (iter in 1 : MAX_ITER){
for (i in 1 : nrow(attrs1)){
x_i = attrs1[i, ]
yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
y_i = y_binary[i]
w_vec = w_vec + (y_i - yhat_i) * x_i
}
}
w_vec
